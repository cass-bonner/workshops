<!DOCTYPE html>
<html lang="en">
<head>
  <title>Bootstrap Example</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="serverless.css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body background="images/background.png">
<script src="js/clipboard.js-master/dist/clipboard.min.js"></script>

    <script>
    var clipboard = new Clipboard('.btn');
    clipboard.on('success', function(e) {
        console.log(e);
    });
    clipboard.on('error', function(e) {
        console.log(e);
    });
    var shiftWindow = function() { scrollBy(0, -70) };
if (location.hash) shiftWindow();
window.addEventListener("hashchange", shiftWindow);


$(document).ready(function () {
        $('ul.nav > li').click(function (e) {
           // e.preventDefault();
            $('ul.nav > li').removeClass('active');
            $(this).addClass('active');                
        });            
    });
    </script>
<nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>                        
      </button>
      <a class="navbar-brand" href="https://aws.amazon.com">  <img src="images/aws_icon.png"/></a>
    </div>
    <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav">
        <li><a href="index.html#">AWS Serverless Workshop</a></li>
        <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="serverless_prerequisites.html#">Setup & Serverless Overview<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="serverless_prerequisites.html#account_setup"><img src="images/bullet.png"/> Account Setup</a></li>
            <li><a href="serverless_prerequisites.html#students"><img src="images/bullet.png"/> Participants Pre-Reqs</a></li>
            <li><a href="serverless.html"><img src="images/bullet.png"/> Serverless Overview</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="serverless-static-website.html#">Lab 1: Static Site<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="serverless-static-website.html#">Lab1: Serverless Static Website</a></li>
            <li><a href="serverless-static-website.html#overview"><img src="images/bullet.png"/> Overview</a></li>
            <li><a href="serverless-static-website.html#vue"><img src="images/bullet.png"/> Vue.js</a></li>
            <li><a href="serverless-static-website.html#s3"><img src="images/bullet.png"/> Amazon S3</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="serverless-dynamic-website.html#">Lab 2: Dynamic Site<span class="caret"></span></a>
          <ol type="1" class="dropdown-menu">
                  <li><a href="serverless-dynamic-website.html#">Lab 2: Serverless Dynamic Website</a></li>
                  <li><a href="serverless-dynamic-website.html#overview"><img src="images/bullet.png"/> Overview</a></li>
                  <li><a href="serverless-dynamic-website.html#usecase"><img src="images/bullet.png"/> Use Case (Pet Type Match)</a></li>
                  <li><a href="serverless-dynamic-website.html#apigsetup"><img src="images/bullet.png"/> Amazon API Gateway - Define API</a></li>
                  <li><a href="serverless-dynamic-website.html#steplogic"><img src="images/bullet.png"/> AWS Step Functions - Coordinate Logic</a></li>
                  <li><a href="serverless-dynamic-website.html#ddbcreate"><img src="images/bullet.png"/> Amazon DynamoDB - Create PetMatchType Tabl</a></li>
                  <li><a href="serverless-dynamic-website.html#lamprime"><img src="images/bullet.png"/> AWS Lambda - Prime PetMatchType Table</a></li>
                  <li><a href="serverless-dynamic-website.html#ddbverify"><img src="images/bullet.png"/> Amazon DynamoDB - Verify Table</a></li>
                  <li><a href="serverless-dynamic-website.html#ddbquery"><img src="images/bullet.png"/> AWS Lambda - Query PetMatchType Table</a></li>
                  <li><a href="serverless-dynamic-website.html#sfnupd"><img src="images/bullet.png"/> AWS Step Functions - Update State Machine w/ Lambda</a></li>
                  <li><a href="serverless-dynamic-website.html#invstate"><img src="images/bullet.png"/> AWS Lambda - Step Functions: Start & Describe Execution</a></li>
                  <li><a href="serverless-dynamic-website.html#apiginteg"><img src="images/bullet.png"/> Amazon API Gateway - Integrate API to Lambda</a></li>
                  <li><a href="serverless-dynamic-website.html#cognito"><img src="images/bullet.png"/> Amazon Cognito - Establish Identity Pool & Permissions</a></li>
                  <li><a href="serverless-dynamic-website.html#updwebcog"><img src="images/bullet.png"/> webapp - Update with Cognito</a></li>
                  <li><a href="serverless-dynamic-website.html#apigunauth"><img src="images/bullet.png"/> Amazon API Gateway - Activate IAM (unauthenticated identity)</a></li>
          </ol>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" data-toggle="dropdown" href="serverless-chatbot.html#">Lab 3: Chatbox<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="serverless-chatbot.html#overview">Lab 3: Serverless Chatbot</a></li>
            <li><a href="serverless-chatbot.html#overview"><img src="images/bullet.png"/> Overview</a></li>
            <li><a href="serverless-chatbot.html#createbot"><img src="images/bullet.png"/> Create Amazon Lex Bot</a></li>
            <li><a href="serverless-chatbot.html#lamfulfill"><img src="images/bullet.png"/> AWS Lambda Fulfillment Function</a></li>
            <li><a href="serverless-chatbot.html#awslcfn"><img src="images/bullet.png"/> awslabs &amp; Cloudformation</a></li>
            <li><a href="serverless-chatbot.html#update_bot_config"><img src="images/bullet.png"/> Update Lex Bot Configuration</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
</nav>
  
<div class="container">
	</p><h1 align="center">Serverless Chatbot on AWS</h1>
<table cellpadding="20px" align="center">
<tbody><tr>
<td width="20%"><a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/lex/latest/dg/what-is.html"><img src="images/lex.png"><br>Amazon Lex</a>
</td><td width="20%"><a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/polly/latest/dg/what-is.html"><img src="images/polly.png"><br>Amazon Polly</a>
</td><td width="20%"><a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/AmazonS3/latest/gsg/GetStartedWithS3.html"><img src="images/s3.png"><br>Amazon S3</a>
</td><td width="20%"><a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/cognito/latest/developerguide/what-is-amazon-cognito.html"><img src="images/cognito.png"><br>Amazon Cognito</a>
</td><td width="20%"><a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/IAM/latest/UserGuide/"><img src="images/iam.png"><br>AWS IAM</a>
</td></tr>
</tbody></table>

<listing class="pretext">Serverless Chatbox Lab Contents
<font size="2">
<img src="images/bullet.png"> <a href="serverless-chatbot.html#overview">Amazon Lex Overview</a>
<img src="images/bullet.png"> <a href="serverless-chatbot.html#createbot">Create Amazon Lex Bot</a>
<img src="images/bullet.png"> <a href="serverless-chatbot.html#lamfulfill">AWS Lambda Fulfillment Function</a>
<img src="images/bullet.png"> <a href="serverless-chatbot.html#awslcfn">awslabs &amp; Cloudformation</a>
<img src="images/bullet.png"> <a href="serverless-chatbot.html#update_bot_config">Update Lex Bot Configuration</a>
</font></listing><font size="2">

<h4 id="overview">Amazon Lex Overview</h4>

<ol>
<listing class="pretext">Now we're going to add a chat bot into our application.  AWS has a number of services in the AI space, one of which is Amazon Lex, an AWS service for building conversational interfaces for any applications using voice and text. With Amazon Lex, the same conversational engine that powers Amazon Alexa is now available to any developer, enabling you to build sophisticated, natural language chatbots into your new and existing applications. Amazon Lex provides the deep functionality and flexibility of natural language understanding (NLU) and automatic speech recognition (ASR) so you can build highly engaging user experiences with lifelike, conversational interactions, and create new categories of products. Lex uses specific terminology - it identifies 'Intents' in response to natural language user input by analyzing 'Utterances', and then collects the required 'slot' values, and once all required slots are provided it 'Fulfills' the intent as shown in this diagram:

<a target="_blank" style="target-new: tab;" href="https://aws.amazon.com/lex/details/"><img src="images/lex-desc.png"></a>

We're going to create a Lex Bot that invokes our same polling PetMatch Lambda Function for fullment and then include it on our site. Note that there are powerful use cases for Lex that allow you users to in a much more conversational style, and the value prop for Lex definitely includes allowing users to "navigate" to their desired "Intent" (all the different actions or insights they would like to perform on the website).  Lex can be used to help reduce the "friction" of navigating traditional websites. The use case here is a simple collection of data and is transactional in nature, but it is still useful to demonstrate Lex. Also, imagine that our PetMatch page was nested in our site 4 "navigations" (clicks,nav bar navigation, etc), Lex could more directly identify and pre-populate data for an Intent.  
 
</listing>
<h4 id="createbot">Create Amazon Lex Chatbot</h4>
<li><listing class="pretext">Navigate to the the 'Lex' Service in the AWS console. Lex is currently available in us-east-1 only so you will have to select that region. You'll see a 'Test Bot' at the bottom of the console - but this will not work until we've defined and buit the bot so let's get started. :)</listing></li>
<li><listing class="pretext">Select 'Create', and then 'Custom Bot'</listing></li>
<li><listing class="pretext">Use [yourid]PetTypeMatch for the Bot name and Select a voice of your liking. </listing></li>
<li><listing class="pretext">Select 'No' to the Child-Directed question, and then select Create. </listing></li>
<li><listing class="pretext">Select 'Create an intent', and then Select 'Create a new intent'.  Call it [yourid]pettypematch, and then select 'Add'.</listing></li>
<li><listing class="pretext">In the Sample Utterances box, type 'Match My Pet Type'.

Select the + icon to add  the utterance as shown below or just hit return:

<img src="images/lex-ui-create.png">

Repeat this process for the following phrases so that you have three utterances listed:
Pet Match
Pet Match for someone who travels {travel} days per month
Match my pet for someone who lives in a {accommodation}
I want to match my pet type
Can you match my pet type

Note the entries with brace {}. Those allow you to pass in the slot value as the user says the Utterance.  We'll test these out in a bit.
</listing></li>
<li><listing class="pretext">Skip over the 'Lambda Initialisation and validation', but be aware that you can invoke a Lambda function to initialize and validate as the slots are field. For example in our case we could invoke a Lambda function which get the list of questions or return the next question to ask, validating input,etc. We would only allow 'yes' or 'no' for many of the questions, and others are restricted to an enumeration.

Further, in our particular match logic, whether or not you choose 'sass' is a major deciding point, so you could start to collect only the questions that are needed based on previous responses, and if we integrate with more of a rules engine long term that will be quite feasible.

</listing></li>
<li><listing class="pretext">Select the (+) icon to the near the 'Slot Type' by in the left navigation.  Fill in the details for a userIdYesNo slot type by first typing 'yes' into the box to the left of the + icon, and only after hitting the + icon or just hitting return. Repeat this for 'no' then say 'Save Slot Type'. Amazon Lex uses the enumeration values you provide in a slot type definition to train its <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/lex/latest/dg/gl-guidelines.html">machine learning models</a>. 

<img src="images/slot-type-add.png">

</listing></li>
<li><listing class="pretext">Add another slot type called [yourUserId]AccommodationType and the enumeration values: house, apartment and townhouse.</listing></li>
<li><listing class="pretext">Add one more slot type called [yourUserId]characterType and the enumeration values:character, complaisant.</listing></li>
<li><listing class="pretext">Add one more slot type called [yourUserId]Chatter and the enumeration values:talking, silence.</listing></li>

<li><listing class="pretext">For the Slots, we're going to replicate the questions we asked on our PetMatch website because those are the values that we need to collect to be able to perform a match, but we'll try to make them a little more conversational.</listing></li>
<li><listing class="pretext">Enter 'duress' for the Name, [yourId]YesNo for the SlotType and 'Do you feel stressed (yes/no)?' for the Prompt. Hit the + icon similar to how you added the Utterances.

<font class="redc">Please ensure ALL slots are required by selecting the 'Required' check box</font>

Repeat the same for all the questions as follows, leaving the slot name exactly as shown with no capitals:

* Ensure that all of the Intents have the checkbox ticked.

Name: walks
Prompt Type: [yourId]YesNo 
Prompt: Do you enjoy taking walks outside (yes/no)? 

Name: sass
Prompt Type: [yourId]Character
Prompt: Do you prefer people with character, or you prefer someone complaisant? 

Name: travel
Prompt Type: AMAZON.NUMBER
Prompt: How many days per month do you travel?

Name: yap
Prompt Type: [yourId]Chatter 
Prompt: Do you enjoy talking or prefer silence? 

Name: accommodation
Prompt Type: [yourI]AccommotationType 
Prompt: Do you live in an apartment,house or townhouse?

Name: outside
Prompt Type: AMAZON.NUMBER
Prompt: If you have an outdoor area, how large is it in sq m? Say 0 if you do not have one 

It should look like this afterwords (except all should be required fields):

<img src="images/lex-slots.png">


</listing></li>
<li><listing class="pretext">Skip the confirmation prompt as the result of the pet match is not something that needs confirmed, and ensure the 'Fulfillment' is expanded. We are going to call our Lambda function to invoke and poll the Step Function - but Amazon Lex requires a specific response from Lambda so we will write a wrapper Lambda around our Polling Lambda.</listing></li>


</ol>
<ol>

<h4 id="lamfulfill"> AWS Lambda Fulfillment Function</h4>
<listing class="pretext">Now we're going to create a Lambda function that will perform the <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/lex/latest/dg/using-lambda.html">fulfillment of our Intent</a>. We're going to use the same synchronous Lambda function that we used for the web page.  The Lambda function used with Amazon Lex has a specific format which you can read about at the above link. The easiest way to get started is to search for a Lambda Blueprint for 'Lex'.  For this lab we'll provide the code.

<b><u>NB: This function must reside in region us-east-1 or any region in which Lex is available</u></b>
</listing>
<li><listing class="pretext">Navigate to Lambda in the Console, and select 'Create a Lambda function'</listing></li>
<li><listing class="pretext">Select 'Blank Function' and skip the Trigger by hitting Next again.</listing></li>
<li><listing class="pretext">Name the Lambda function [yourid]invokeLambdaSM. Not that this is a type of utility function that can be genericised and re-used by all. However with the permissions setup for this lab to avoid accidental overwrite, you won't have permissions to do that.</listing></li>
<li><listing class="pretext">Paste the following into the body of your function.

<button class="btn btn-outline-secondary btn-sm" data-clipboard-target="#invlam">Copy</button>
	<pre><span id="invlam">'use strict';

var aws = require('aws-sdk');
var lambda = new aws.Lambda({
    region : process.env.TARGET_REGION
});

 // --------------- Helpers to build responses which match the structure of the necessary dialog actions -----------------------

function elicitSlot(sessionAttributes, intentName, slots, slotToElicit, message) {
    return {
        sessionAttributes,
        dialogAction: {
            type: 'ElicitSlot',
            intentName,
            slots,
            slotToElicit,
            message,
        },
    };
}

function close(sessionAttributes, fulfillmentState, message) {
    return {
        sessionAttributes,
        dialogAction: {
            type: 'Close',
            fulfillmentState,
            message,
        },
    };
}

function delegate(sessionAttributes, slots) {
    return {
        sessionAttributes,
        dialogAction: {
            type: 'Delegate',
            slots,
        },
    };
}


function buildValidationResult(isValid, violatedSlot, messageContent) {
    if (messageContent === null) {
        return {
            isValid,
            violatedSlot,
        };
    }
    return {
        isValid,
        violatedSlot,
        message: { contentType: 'PlainText', content: messageContent },
    };
}


function handlePetMatch(intentRequest, callback,context) {
    
    // invoke our Lambda function to give us the resutMatch
    
    
    
    var slotValues = intentRequest.currentIntent.slots;
    console.log("in handlePetMatch:  " + JSON.stringify(slotValues));
    
    // map our conversational response to the expected model by our step function.
    
    if(slotValues.sass &amp;&amp; ((slotValues.sass.toLowerCase().indexOf("sass") &gt; -1) ||
        (slotValues.sass.toLowerCase().indexOf("character") &gt; -1))) {
        slotValues.sass = 'yes'
    } else {
        slotValues.sass = 'no'
    }
    if(slotValues.yap &amp;&amp; ((slotValues.yap.toLowerCase().indexOf("yap") &gt; -1) ||
        (slotValues.yap.toLowerCase().indexOf("talk") &gt; -1))) {
        slotValues.yap = 'yes'
    } else {
        slotValues.yap = 'no'
    }
    console.log("after transformation:  " + JSON.stringify(slotValues));
    
    var params = {
      FunctionName: process.env.FUNCTION_ARN,
      Payload: JSON.stringify(slotValues, null, 2) 
    };
    console.log("params: "+ params);
    lambda.invoke(params, function(error, data) {
      if (error) {
          console.log("error occurred: " + error);
        context.done('error', error);
      }
      if(data){
        var json = JSON.parse(data.Payload) 
        console.log("data: " + json);
        var response = "Your Pet Match is a " + json.petTypeId + " of breed " +   
            json.breed + ". The pet is classified as a " + 
            json.Classification + " and the average life expectancy is " + json.lifespan;

       // Send the response back to ex
       callback(close(intentRequest.sessionAttributes, 'Fulfilled',
            { contentType: 'PlainText', content: response
            }));
      }
    });
  
}




 // --------------- Intents -----------------------

/**
 * Called when the user specifies an intent for this skill.
 */
function dispatch(intentRequest, callback, context) {
    console.log(`dispatch userId=${intentRequest.userId}, intentName=${intentRequest.currentIntent.name}`);

    
    console.log("intentRequest: " + JSON.stringify(intentRequest));
    const intentName = intentRequest.currentIntent.name;

    // Dispatch to your skill's intent handlers
    if (intentName === process.env.INTENT_NAME) {
        return handlePetMatch(intentRequest, callback);
    }
    throw new Error(`Intent with name ${intentName} not supported`);
}

// --------------- Main handler -----------------------

// Route the incoming request based on intent.
// The JSON body of the request is provided in the event slot.
exports.handler = (event, context, callback) =&gt; {
    try {
        // By default, treat the user request as coming from the America/New_York time zone.
        process.env.TZ = 'America/New_York';
        console.log(`event.bot.name=${event.bot.name}`);
        console.log('event=' + JSON.stringify(event));

        if (event.bot.name !== process.env.BOT_NAME) {
             callback('Invalid Bot Name: ' + event.bot.name);
        }
        
        dispatch(event, (response) =&gt; callback(null, response), context)
    } catch (err) {
        callback(err);
    }
};

</span></pre>


</listing></li>
<li><listing class="pretext"><font class="redc">DEFINE four Environment Variables</font> (below the function) substituting the appropriate region name and your function name. Note that ap-southeast-2 is Sydney, but you can search for any region <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/general/latest/gr/rande.html">here</a>:

TARGET_REGION=ap-southeast-2
FUNCTION_ARN=[yourid]InvokeStateMachineWithResults
BOT_NAME=[userid]PetTypeMatch
INTENT_NAME=[userId]pettypematch

</listing></li>
<li><listing class="pretext">In the advanced section, increase the timeout to 30 seconds.</listing></li>
<li><listing class="pretext">For the role, select [userId]LambdaInvokeLambda</listing></li>
<li><listing class="pretext">Once your function is complete - navigate back to Lex and select your new Function (NB: YOU will Likely need to navigate away from the Lex screen and re-enter the Intent to see the InvokeSM Function) for the 'Fulfillment' and then select 'OK' to the popup and then scroll down and select 'Save Invent'</listing></li>
<li><listing class="pretext">Select 'Build' from the top of the page to the left of the 'Publish' button.</listing></li>
<li><listing class="pretext">Once the build is complete (this can take a short while),  the bot is ready to be tested, but before we do that let's kick off a CloudFormation template that will take some time to build and then we will come back and test our bot. </listing></li>
</ol>
<h4 id="awslcfn">awslabs &amp; Cloudformation.</h4>
<ol>
<li><listing class="pretext">Now Before we test this all, we're going to "bootstrap" our efforts by using a lab off <a target="_blank" style="target-new: tab;" href="https://github.com/awslabs">awslabs on github</a>. It will take some time to build so we'll kick this off and then come back and test our bot.
Navigate to <a target="_blank" style="target-new: tab;" href="https://github.com/awslabs/aws-lex-web-ui">this url</a> in your browser in a new tab:</listing></li>
<br>

<button class="btn btn-outline-secondary btn-sm" data-clipboard-target="#lexwebui">Copy</button>
<pre><span id="lexwebui">https://github.com/awslabs/aws-lex-web-ui</span></pre>

<p></p>
<div class="image-blurred-edge"></div>

<br>
<ol>
<li><listing class="pretext">Have a quick read of the architecture and then navigate to the section called 'Lauching'. Select the 'Launch Stack' Icon and which will take you to <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html">CloudFormation</a> in the AWS Console.  Ensure you are in the us-east-1 region.</listing></li>
<li><listing class="pretext">Copy the link where it says 'Specify an Amazon S3 template URL or click  

<button class="btn btn-outline-secondary btn-sm" data-clipboard-target="#yaml">Copy</button>
<pre><span id="yaml"> https://s3.amazonaws.com/aws-bigdata-blog/artifacts/aws-lex-web-ui/artifacts/templates/master.yaml</span></pre>
</listing></li>

<listing class="pretext">AWS CloudFormation gives developers and systems administrators an easy way to create and manage a collection of related AWS resources, provisioning and updating them in an orderly and predictable fashion.

You can use AWS CloudFormation’s sample templates or create your own templates to describe the AWS resources, and any associated dependencies or runtime parameters, required to run your application. You don’t need to figure out the order for provisioning AWS services or the subtleties of making those dependencies work. CloudFormation takes care of this for you. After the AWS resources are deployed, you can modify and update them in a controlled and predictable way, in effect applying version control to your AWS infrastructure the same way you do with your software. 
</listing>

<li><listing class="pretext">Enter that url into another browser tab and have a quick look at the CloudFormation template that creates the lab and try to understand and find the Services that will be launched.  
</listing></li>

<li><listing class="pretext">  Go back to the CloudFormation tab in your browser and click the Next button and be sure to <font color="red" change="" the="" stackname<="" font="">. Put <font class="redc">your unique userId</font> of your work login in front of the existing name so it looks something like this:

<pre>[userid]-lex-web-ui</pre> 

Similarly with <b><u><font class="redc">EVERY</font></u></b> parameter - preface it with your unique id. This will make it much easier to find your resources if we are all working in the same AWS account.</font></listing></li>
<li><listing class="pretext">For the BotName - don't use the default value -   <font class="redc">change it to the name of your bot</font>.</listing></li> 
<li><listing class="pretext">For the Cognito Identity Pool -  don't use the default value -   <font class="redc">change it to the name of your Cognito Identity Pool</font>.</listing></li> 
<li><listing class="pretext">Your final CloudFormation Parameters screen should look something like the following - except <font color="redc">use your unique Id</font> instead of 'cass'

<img src="images/cloudf.png"/>
</listing></li>

<li><listing class="pretext"> Hit Next until the last page and <font class="redc">select the 'I acknowledge</font> that AWS CloudFormation might create IAM resources with custom names.' and click 'Create'</listing></li>
<li><listing class="pretext">This will take some time to build but in the meantime we have a few things to complete:

  <img src="images/bullet.png"> Read through the rest of the awslabs <a target="_blank" style="target-new: tab;" href="https://github.com/awslabs/aws-lex-web-ui">aws-lex-web-ui</a>
  <img src="images/bullet.png">  If you haven't already, test your Lex bot via the console. (Instructions below)
  <img src="images/bullet.png">   Since you are using our own Cognito Identity Pool, you will need to add a policy to the role. (Instructions below) 
</listing></li>

  <h5>Test Your Bot</h5>
  <li> <listing class="pretext"> Navigate to the Lex console and expand the bot. Enter 'PetMatch' into the chatbot and it should identify your intent, or responds with a Clarification Prompt if it can not identify any intent. </listing></li>
  <li><listing class="pretext">You can see the Clarification Prompt text, which is configurable on the Error Handling section of your bot. </listing></li>
  <li><listing class="pretext">Your bot should collect all required values and then invoke our Lambda function for Fulfilment, returning a summary of your match.  </listing></li>

  <h5>Add appropriate permissions to your Cognito Identity Pool</h5>
     
  <listing class="pretext">As above, Since you are using our own Cognito Identity Pool, you will need to link a role to it. The associated role should allow access to the Lex PostText/PostContent API calls and Polly SynthesizeSpeech. Similar to how we added in the ability to invoke API Gateway to our cognito role, we need to add another policy. Let's do that now.</listing>

<li><listing class="pretext">Navigate to IAM and select 'Roles'</listing></li>
<li><listing class="pretext">Search for your Cognito Role</listing></li>
<li><listing class="pretext">Select the role and then 'Create Role Policy':

<img src="images/createRolePolicy.png">
</listing></li>
<li><listing class="pretext">For the Policy Name, use [yourUserId]LexPostPollySynth
</listing></li>

<li><listing class="pretext">In the policy editor, copy the following policy and paste, <font class="redc">substituting the [] and XXXX variables</font> with the actual values with your region (e.g. us-east-1), your AWS account number, and your bot name respectively:


 <button class="btn btn-outline-secondary btn-sm" data-clipboard-target="#policylex">Copy</button>
<pre><span id="policylex">{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Action": [
                "lex:PostText",
                "lex:PostContent"
            ],
            "Resource": [
                "arn:aws:lex:[your region]:XXXXXXXX:bot:[yourBotName]:*"
            ],
            "Effect": "Allow"
        },
        {
            "Action": [
                "polly:SynthesizeSpeech"
            ],
            "Resource": "*",
            "Effect": "Allow"
        }
    ]
}</span></pre>

There are two statements in this policy. This first allows a specific resource (your bot) to invoke the Lex PostText and PostContent APIs which are required for your bot to function appropriately. The second gives all resources the ability to call polly:SynthesizeSpeech to allow us to use Polly to synthesize our Speech and provide voice.
</listing></li>

<li><listing class="pretext">Save the policy - you should now have three policies in total on your Cognito Unauth Role.

</listing></li>
 
<h4 id="update_bot_config">Update Your Amazon Bot Configuration.</h4>
<listing class="pretext">Hopefully by now your CloudFormation stack has completed. Navigate to <a target="_blank" style="target-new: tab;" href="https://console.aws.amazon.com/cloudformation">CloudFormation in the console</a>, and you should see that at least 3 Stacks have been created - one with the name you specified and two others that have 'CodeCommitRepo' and 'Pipeline' appended (NB There may be more if you did not supply your Bot or Cognito Identity Pool). We will work with and explain these additional stacks in a bit, but for now select your base stack name (it should be called what you named it in the CloudFormation template and it will have some characters appended - this is expected).
</listing></li>
<li><listing class="pretext">Confirm that the CloudFormation stack status is 'CREATE_COMPLETE' and if not wait until it is.
</listing></li>
<li><listing class="pretext">Expand the 'Outputs' Arrow and you should see something like this:

<center><img src="images/cfn-outputs.png"/></center>

</listing></li>
<li><listing class="pretext">Copy the URL for the Ouptut Labelled 'WebAppUrl' - and open this in a new tab.
</listing></li>
<li><listing class="pretext">You will see a page which exposes an Amazon Lex Bot, but talks of Flowers. Actually though, if you specified your Bot in the CloudFormation template, then the Bot behind the webapp is actually your bot (if you ignore the comments about Ordering Flowers :)). Enter one of your utterances and execute your Bot in Full via the webapp.
</listing></li>
<li><listing class="pretext">Ok, that's all well and good but we want it to be tailored to our Bot so that we can incorporate it into our bot.
</listing></li>
 <h4 id="modify_bot">Configuring and Setup for your CI/CD Pipeline</h4> 
<li><listing class="pretext">So, we want to modify our Bot so we can embed it in our website and make it relevant for our application. Fortunately, the AWS Proserve Consultants who wrote the aws-lex-web-ui, have provided a slick way to accommodate this requirement. You will recall that there were four (4) outputs in our CloudFormation Stack. Scroll up and look at the image above again and you will see that there is one for a CodeCommitURL and another for a PipelineUrl. In fact the project uses three key AWS Services to provide an OOTB Pipeline to allow you to modify, commit and deploy your ChatBot Webapp as depicted in their diagram:

<center><img src="images/cfn-stack.png"/> </center>

<img src="images/arrow.png"> <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/codebuild/latest/userguide/welcome.html"> AWS CodeBuild</a> is a fully managed build service in the cloud. AWS CodeBuild compiles your source code, runs unit tests, and produces artifacts that are ready to deploy. AWS CodeBuild eliminates the need to provision, manage, and scale your own build servers. It provides prepackaged build environments for the most popular programming languages and build tools such as Apache Maven, Gradle, and more. You can also customize build environments in AWS CodeBuild to use your own build tools. AWS CodeBuild scales automatically to meet peak build requests.

<img src="images/arrow.png"> <a target="_blank" style="target-new: tab;" href="https://aws.amazon.com/documentation/codecommit/">AWS CodeCommit</a> is a fully-managed source control service that makes it easy for companies to host secure and highly scalable private Git repositories. CodeCommit eliminates the need to operate your own source control system or worry about scaling its infrastructure. You can use CodeCommit to securely store anything from source code to binaries, and it works seamlessly with your existing Git tools.

<img src="images/arrow.png"> <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html">AWS CodePipeline</a> is a continuous delivery service that enables you to model, visualize, and automate the steps required to release your software.

And the specific Deployment Pipeline for this Project looks like this:

<center><img src="images/lex-pipeline.png"/> </center>


</listing></li>

<li><listing class="pretext">You can read more about the pipeline at the <a target="_blank" style="target-new: tab;" href="https://github.com/awslabs/aws-lex-web-ui">aws-lex-web-ui awslabs</a>, but our next step will be to Setup for  <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html">AWS CodeCommit</a>. This Lab assumes that you will want to setup for connectivity from an IDE, but please utilize the link above for alternative setup and revert to the <a target="_blank" style="target-new: tab;" href="http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up-gc.html">AWS Instructions</a> should you hit any issues..
</listing></li>

<li><listing class="pretext"><a target="_blank" style="target-new: tab;" href="https://console.aws.amazon.com/iam">Navigate to IAM</a> in the AWS Console, as we are going to setup your userId to be able to access the AWS CodeCommit Repository. NB Feel free to utilize any alternative approach as desired.
</listing></li>
<li><listing class="pretext">Select 'Users' and then select your AWS UserId. (NB: Another approach is to add this to the adminForUsername group too allow for all AWS participants but I will leave that to you)
</listing></li>
<li><listing class="pretext">On the 'Permissions' tab, choose 'Add Permissions'.
</listing></li>
<li><listing class="pretext">In 'Grant permissions', choose Attach existing policies directly.
</listing></li>
<li><listing class="pretext">Select/Filter for AWSCodeCommitFullAccess from the list of policies and select the checkbox to include this policy. Remove the AWSCodeCommit... filter if you specified it and search for 'IAMSelf'.. and then select/tick 'IAMSelfManageServiceSpecificCredentials'. And finally search for 'IAMReadOnlyAcces' and tick the checkbox to include this policy, and then select 'Next: Review'.  NB for more information about managed policies for AWS CodeCommit, see <a href="http://docs.aws.amazon.com/codecommit/latest/userguide/access-permissions.html#access-permissions-managed-policies">Managed Policies for AWS CodeCommit</a>.
</listing></li>
<li><listing class="pretext">Select 'Add Permissions' and you should see the three policies above have been added to your user (or Group depending upon your approach).
</listing></li>
<li><listing class="pretext">Navigate to the 'Security credentials' tab for your userId, and scroll to the bottom.
</listing></li>
<li><listing class="pretext">Under the area 'HTTPS Git credentials for AWS CodeCommit', select 'Generate', and then take note of the username and password and optionally Download the Credentials File. You will need these credentials to connect to AWS CodeCommit from your IDEA or other HTTPS-based connectivity.
</listing></li>
<li><listing class="pretext">Navigate to your Favourite IDE, and checkout source code from Git.  THere are many IDEs and techniques here so I won't provide too much detail as it is also subject to change. However for one example, if you utilize IntelliJ, Create a 'New' Project from 'Version Control' and select Git. 
</listing></li>
<li><listing class="pretext">For the Url, enter the CodeCommit URL from your CloudFormation Stack, where a fork of the aws-lex-web-ui repository was created.
</listing></li>
<li><listing class="pretext">For the Username and Password credentials, enter the details you generated from within AWS IAM Security Credentials that you noted.
</listing></li>
<li><listing class="pretext">You will now have a clone of the git fork that was created for your CodeCommit, so you can make changes and upon commit this will integrate to CodeBuild and your Pipeline and be deployed to your S3 bucket.
</listing></li>
 <h4 id="modify_bot">Modifying the webapp Bot</h4> 
<li><listing class="pretext">At this point we should be setup to make and commit changes to our AWS CodeCommit repo which in turn will initiate our build pipeline and deploy our updates resources. But wait a minute, what do we need to change? Well, most likely not too much - perhaps the Title, Introduction Text, and colour of the webapp ChatBot. And lo and behold, take a moment to appreciate the good work of the ProServe Consultants once again because these minor modifications are actually a means of configuration. Further modifications are also fairly easy by modifying the source code.
</listing></li>
<li><listing class="pretext">In your IDE or favourite editor, open the file lex-web-ui/src/config/config.dev.json.  You should see that some of the values already reflect the input into your CloudFormation template such as the poolId, botName and 'ParentOrigin' (if you defined this).
</listing></li>
<li><listing class="pretext">Edit the config.dev.json, and change the values of invalid fields such as the:

* initialText 
* initialSpeechInstruction
* polly.voiceId (if you want a voice other than Salli - see <a target="_blank" style="target-new: tab;" href="https://console.aws.amazon.com/polly/">AWS Polly</a> for the voice options) 
* pageTitle
* toolbarTitle

This diagram tries to highlight the field you might want to modify:

<center><img src="images/config.dev.mod.png"/></center>
</listing></li>
<li><listing class="pretext">For our purposes, <font class="redc">make THE SAME changes to lex-web-ui/src/config/config.prod.json</font>. This will allow us to quickly test the changes since we have not yet incorporated the bot to our local webapp.
</listing></li>
<li><listing class="pretext">If you want to change the colour of the Bot (from red to something else), then we have one more field to modify, which is index.js within the same directory as config.dev.json.  Search for 'toolbarColour (mispelled as toolbarColor of course - the yanks! ;), and replace the value 'red' with whatever html colour you desire. You may note that some of the values you updated in config.dev.json are in this file but don't worry your config.dev.json files will be updated).
</listing></li>
<li><listing class="pretext">Once modified, commit the two files, and you should find that your build pipeline is kicked off and your bot at the webapp is updated. Be sure to push the files to complete the update.
</listing></li>
<li><listing class="pretext">You can follow your build pipeline most readily by navigating to <a target="_blank" style="target-new: tab;" href="https://console.aws.amazon.com/codepipeline">AWS CodePipeline</a> and selecting your pipeline (e.g. [yourUserId]-pet-match-ui). In the diagram below you will see that the BuildDeploy is still inprogress- but once this completes it will turn green and say 'Succeeded' rather than 'In Progress'. Once that is complete - navigate back to the webapp URL from your CloudFormation Stack and you should see that not only is your Lex Bot still the engine, but it should have the additional configurations. 
<center><img src="images/cass-codepipeline.png"/></center>
</listing></li>
<li><listing class="pretext">Ok great, it's looking like the bot I'd like to display in PetMatch (or other website), but how do I integrate this back into my webapp?
</listing></li>
 <h4 id="include_bot">Incorporating the Amazon Lex Bot to our webapp</h4> 
<li><listing class="pretext">In the previous section, we configured our Amazon Lex Bot to appear as desired but we now need to incorporate our bot into our webapp.
</listing></li>
<li><listing class="pretext">Fortunately once again, our good friends from AWS ProServe have made this fairly easy by allowing us to include our server-side bot as an iframe. You may recall that from the CloudFormaton 'Outputs' tab there was a fourth output that we have not yet explored. It was appropriately labelled 'ParentPageUrl'. Feel free to navigate to this URL for two (2) reasons:

1) If you explore its implementation, you will see that it is a good example for how to embed an Amazon Lex Bot as an Iframe.
2) The parent page provides additonal details about he Bot invocation that you do not (currently) get from the AWS Console. As such it *might* be useful for you to use for testing your Amazon Lex Bot, at least for a limited period.

</listing></li>
<li><listing class="pretext">Once you have explored the parent page URL (if interested), let's apply a similiar approach and incorporate our Bot into our existing webapp.
</listing></li>
<li><listing class="pretext">Analyzing the parent bot or by following the instructions at the 'lex-web-ui/static/iframe/README.md', you should be able to incorporate your server-side Bot most readily
</listing></li>
<li><listing class="pretext">I will duplicate the instructions here, but please see your local README.md for the latest instructions as the may change over time.
</listing></li>

<li><listing class="pretext">Copy all the files from 'lex-web-ui/static/iframe/' to a directory of your choice in your local aws-serverless-workshop build. The recommended directory is aws-serverless-workshop/static/iframe as that will require the fewest changes but any directory is acceptable so long as you modify the relevant paths in future steps
</listing></li>
<li><listing class="pretext">Now we need to add the following includes into our index.html in the base of aws-serverless-workshop - WITH appropriate modifictatons:

 <button class="btn btn-outline-secondary btn-sm" data-clipboard-target="#botmod">Copy</button>
<pre><span id="botmod">
  &lt;link rel="stylesheet" type="text/css" href=[INSERT-PATH-TO]/static/iframe/bot.css">

  &lt;script src="[INSERT-PATH-TO]/static/iframe/bot-loader.js"></script>

</pre></span>

Modify the index.html to point to the appropriate relative paths based on where you placed the files.
</listing></li>
<li><listing class="pretext">Edit the config.json which should be located in parallel to the files you copied in from the 'lex-web-ui/static/iframe' directory.  The cognitoPoolId and region should be set appropriately, but correct them if not.
</listing></li>
<li><listing class="pretext">You can leave the 'iframeOrigin' as it is to 'localhost' and test locally, or modify it to your webappurl  (from CloudFormation outputs) to test it in full. 
</listing></li>
<li><listing class="pretext">Once you've reloaded  
</listing></li>

</ul>
</body></html>
